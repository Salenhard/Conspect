# Этапы компиляции
## 1. Препроцессинг

Самая первая стадия компиляции программы.

Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования.
На данной стадии происходит происходит работа с препроцессорными директивами.
Например, препроцессор добавляет хэдеры в код (`#include`), убирает комментирования, заменяет макросы (#define) их значениями,
выбирает нужные куски кода в соответствии с условиями #if, #ifdef и #ifndef.

Хэдеры, включенные в программу с помощью директивы #include, рекурсивно проходят стадию препроцессинга и включаются в выпускаемый файл.
Однако, каждый хэдер может быть открыт во время препроцессинга несколько раз, поэтому, обычно,
используются специальные препроцессорные директивы, предохраняющие от циклической зависимости.

Получим препроцессированный код в выходной файл driver.ii (прошедшие через стадию препроцессинга C++ файлы имеют расширение .ii),
используя флаг -E, который сообщает компилятору, что компилировать (об этом далее) файл не нужно, а только провести его препроцессинг:

```bash
g++ -E driver.cpp -o driver.ii
```

Взглянув на тело функции main в новом сгенерированном файле, можно заметить, что макрос RETURN был заменен:

```c++
int main() {
    cout << "Hello, world!" << endl;
    return 0;
}

driver.ii
```
В новом сгенерированном файле также можно увидеть огромное количество новых строк, это различные библиотеки и хэдер iostream.

## 2. Компиляция

На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код.
Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.

Ассемблерный код — это доступное для понимания человеком представление машинного кода.

Используя флаг -S, который сообщает компилятору остановиться после стадии компиляции, получим ассемблерный код в выходном файле driver.s:
```bash
$ g++ -S driver.ii -o driver.s
driver.s
```
Мы можем все также посмотреть и прочесть полученный результат. Но для того, чтобы машина поняла наш код,
требуется преобразовать его в машинный код, который мы и получим на следующем шаге.

## 3. Ассемблирование

Так как x86 процессоры исполняют команды на бинарном коде, необходимо перевести ассемблерный код в машинный с помощью ассемблера.
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле.
Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода.
 Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.
Далее возможно сохранение данного объектного кода в статические библиотеки для того, чтобы не компилировать данный код снова.
Получим машинный код с помощью ассемблера (as) в выходной объектный файл driver.o:
```bash
$ as driver.s -o driver.o
```
Но на данном шаге еще ничего не закончено, ведь объектных файлов может быть много и нужно их всех соединить в единый исполняемый файл с помощью компоновщика (линкера).
 Поэтому мы переходим к следующей стадии.

## 4. Компоновка

Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем.
 Для того, чтобы понять как происходит связка, следует рассказать о таблице символов.

Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций,
классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости.
Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.
Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет
способен в дальнейшем построить связи между данными среди множества других
объектных файлов и создать единый исполняемый файл из них.

Получим исполняемый файл driver:

```bash
$ g++ driver.o -o driver // также тут можно добавить и другие объектные файлы и библиотеки
```

## 5. Загрузка

Последний этап, который предстоит пройти нашей программе — вызвать загрузчик для загрузки нашей программы в память.
 На данной стадии также возможна подгрузка динамических библиотек.

Запустим нашу программу:

```bash
$ ./driver
// Hello, world!
```

Источник: https://habr.com/ru/post/478124/
